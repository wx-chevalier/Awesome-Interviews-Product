# 2026.01-产品经理 SQL 面试题

# 产品经理 SQL 常见面试题

你关注的是产品经理岗位的 SQL 面试题，这类面试的核心**不是考察复杂语法细节，而是业务逻辑拆解能力和数据思维**，重点围绕产品核心指标（注册、付费、留存等）展开，以下是高频考题及详细解析：

## 一、 基础必会题型（门槛级，必须掌握）

这类题目是面试入门，考察单表查询、聚合函数的基础使用，对应产品日常的简单数据统计需求。

### 1. 单表筛选与简单聚合

**题目**：现有用户表`user_info`（简化结构如下），请统计 2025 年 10 月注册的女性用户数量，要求输出：注册月份、女性用户数。

| 字段名        | 字段类型 | 字段说明           |
| ------------- | -------- | ------------------ |
| user_id       | varchar  | 用户唯一 ID        |
| gender        | tinyint  | 性别（1=男，2=女） |
| register_time | datetime | 用户注册时间       |

**解题思路**：

1.  筛选条件：注册时间在 2025-10-01 至 2025-10-31，性别为女性（gender=2）；
2.  聚合统计：用`COUNT()`统计符合条件的用户数，用`DATE_FORMAT()`提取注册月份；
3.  字段别名：为了输出更易读，给统计结果起别名。

**SQL 示例**：

```sql
-- 统计2025年10月女性注册用户数
SELECT
  DATE_FORMAT(register_time, '%Y-%m') AS register_month, -- 提取注册月份（格式：年-月）
  COUNT(user_id) AS female_user_count -- 统计女性用户数
FROM
  user_info
WHERE
  gender = 2 -- 筛选女性用户
  AND register_time BETWEEN '2025-10-01 00:00:00' AND '2025-10-31 23:59:59' -- 筛选10月注册用户
GROUP BY
  register_month; -- 按月份分组（此处仅1个月份，分组可省略，但养成规范习惯）
```

**产品关注要点**：这类查询对应产品日常的「新增用户分性别/分渠道统计」，是评估用户增长质量的基础数据。

### 2. 分组聚合与条件过滤（GROUP BY + HAVING）

**题目**：基于上述`user_info`表，新增字段`city`（用户所在城市，varchar 类型），请按城市分组，统计每个城市的付费用户数（新增字段`is_pay`：1=付费用户，0=非付费用户），仅保留付费用户数大于 100 的城市，输出：城市名称、付费用户数（按付费数降序排列）。

**解题思路**：

1.  先筛选：仅保留付费用户（is_pay=1）；
2.  再分组：按城市`city`分组；
3.  后过滤：用`HAVING`过滤分组后付费数>100 的城市（注意：分组后的条件用 HAVING，分组前用 WHERE）；
4.  排序：用`ORDER BY`按付费用户数降序排列。

**SQL 示例**：

```sql
-- 按城市统计付费用户数（仅保留付费数>100的城市）
SELECT
  city,
  COUNT(user_id) AS pay_user_count
FROM
  user_info
WHERE
  is_pay = 1 -- 先筛选付费用户（分组前条件）
GROUP BY
  city -- 按城市分组
HAVING
  pay_user_count > 100 -- 过滤付费数>100的城市（分组后条件）
ORDER BY
  pay_user_count DESC; -- 按付费数降序排列
```

**产品关注要点**：产品经理常用该查询做「区域用户付费能力分析」，用于制定差异化的区域运营策略（如付费用户多的城市加大推广投入）。

### 3. 多表关联查询（JOIN，高频）

产品经理常需要关联多张表（用户表、订单表、行为表等）获取完整数据，核心掌握`INNER JOIN`（内连接，仅保留两表匹配数据）和`LEFT JOIN`（左连接，保留左表所有数据，右表无匹配则为 NULL）。

**题目**：现有用户表`user_info`（同上）和订单表`order_info`（结构如下），请关联两张表，统计每个用户的累计付费金额，要求输出：用户 ID、用户名（`user_info`表`user_name`）、累计付费金额（无付费记录则显示 0）。

| 字段名       | 字段类型 | 字段说明     |
| ------------ | -------- | ------------ |
| order_id     | varchar  | 订单唯一 ID  |
| user_id      | varchar  | 关联用户 ID  |
| order_amount | decimal  | 订单金额     |
| pay_time     | datetime | 订单支付时间 |

**解题思路**：

1.  表关联选择：需要保留所有用户（包括未付费用户），因此用`LEFT JOIN`（左表=user_info，右表=order_info）；
2.  关联条件：两表通过`user_id`关联；
3.  聚合统计：按`user_id`分组，用`SUM()`统计累计订单金额，用`IFNULL()`处理无付费记录的情况（显示 0）。

**SQL 示例**：

```sql
-- 统计每个用户的累计付费金额
SELECT
  u.user_id,
  u.user_name,
  IFNULL(SUM(o.order_amount), 0) AS total_pay_amount -- 无付费记录则显示0
FROM
  user_info u -- 左表：用户表，起别名u
LEFT JOIN
  order_info o -- 右表：订单表，起别名o
ON
  u.user_id = o.user_id -- 关联条件：用户ID一致
GROUP BY
  u.user_id, u.user_name -- 按用户ID和用户名分组
ORDER BY
  total_pay_amount DESC;
```

**产品关注要点**：该查询对应产品核心需求「用户付费价值分层」（如高价值用户、低价值用户、非付费用户），是制定用户运营策略（如会员体系、精准推送）的关键数据。

## 二、 高频进阶题型（拉开差距，核心考察数据思维）

这类题目是产品经理 SQL 面试的重点，围绕窗口函数、留存率、去重统计等核心场景展开，考察业务拆解能力。

### 1. 窗口函数（核心中的核心，高频必考）

窗口函数（OVER()）与`GROUP BY`的区别：`GROUP BY`分组后会合并多行数据为一行，窗口函数则保留原始行数据，同时附加分组统计结果，核心用于排名、累计统计等场景，产品经理需掌握两类常用窗口函数：

#### （1） 排名窗口函数：ROW_NUMBER() / RANK() / DENSE_RANK()

**题目**：基于上述`user_info`和`order_info`表，按城市分组，给每个城市的付费用户按累计付费金额降序排名（允许并列，且并列后后续排名不跳跃，例如：1、2、2、3），要求输出：用户 ID、城市、累计付费金额、排名。

**解题思路**：

1.  先统计每个用户的累计付费金额（关联两表+分组聚合）；
2.  再用窗口函数`DENSE_RANK()`进行分组排名（满足“并列后排名不跳跃”的要求）；
3.  窗口分区条件：按城市`city`分区（`PARTITION BY city`），排序条件：按累计付费金额降序（`ORDER BY total_pay_amount DESC`）。

**SQL 示例**：

```sql
-- 每个城市付费用户按累计金额排名
WITH user_total_pay AS (
  -- 子查询/CTE：先统计每个用户的累计付费金额
  SELECT
    u.user_id,
    u.city,
    IFNULL(SUM(o.order_amount), 0) AS total_pay_amount
  FROM
    user_info u
  LEFT JOIN
    order_info o
  ON
    u.user_id = o.user_id
  WHERE
    IFNULL(SUM(o.order_amount), 0) > 0 -- 仅保留付费用户
  GROUP BY
    u.user_id, u.city
)
SELECT
  user_id,
  city,
  total_pay_amount,
  DENSE_RANK() OVER (PARTITION BY city ORDER BY total_pay_amount DESC) AS pay_rank
FROM
  user_total_pay;
```

**三种排名函数区别（产品经理需熟记）**：

- `ROW_NUMBER()`：不允许并列，即使金额相同，排名也会递增（1、2、3、4）；
- `RANK()`：允许并列，并列后排名跳跃（1、2、2、4）；
- `DENSE_RANK()`：允许并列，并列后排名不跳跃（1、2、2、3）；

**产品关注要点**：该查询用于「城市内高价值用户筛选」（如每个城市 TOP10 付费用户），支撑区域精细化运营。

#### （2） 聚合窗口函数：SUM() / COUNT() OVER()

**题目**：现有订单表`order_info`，请统计 2025 年每个月的订单数，以及截至当月的累计订单数，要求输出：月份、当月订单数、累计订单数。

**解题思路**：

1.  先按月份分组，统计当月订单数；
2.  用`SUM(当月订单数) OVER (ORDER BY 月份)`实现累计统计（无`PARTITION BY`，表示全局分区，按月份排序累计）。

**SQL 示例**：

```sql
-- 统计每月订单数及累计订单数
WITH month_order AS (
  -- 子查询：统计每月订单数
  SELECT
    DATE_FORMAT(pay_time, '%Y-%m') AS order_month,
    COUNT(order_id) AS month_order_count
  FROM
    order_info
  WHERE
    pay_time BETWEEN '2025-01-01 00:00:00' AND '2025-12-31 23:59:59'
  GROUP BY
    order_month
)
SELECT
  order_month,
  month_order_count,
  SUM(month_order_count) OVER (ORDER BY order_month) AS cumulative_order_count -- 累计订单数
FROM
  month_order
ORDER BY
  order_month;
```

**产品关注要点**：累计订单数是产品「业务增长趋势分析」的核心指标，用于判断业务是否处于上升/下降通道，支撑战略决策。

### 2. 留存率统计（产品核心指标，必考）

留存率是衡量产品粘性的关键指标，产品经理必须掌握其 SQL 实现逻辑，核心定义：次日留存、7 日留存、30 日留存。

**题目**：定义「次日留存」：用户注册次日（自然日）有登录行为即为次日留存用户。现有用户表`user_info`（含`user_id`、`register_time`）和用户登录表`login_info`（含`user_id`、`login_time`），请统计 2025 年 10 月 1 日-10 月 7 日每天的注册用户数及对应的次日留存率，要求输出：注册日期、注册用户数、次日留存率（保留 2 位小数）。

**解题思路**：

1.  步骤 1：筛选目标时间段（10.1-10.7）的注册用户，提取注册日期；
2.  步骤 2：筛选登录用户，提取登录日期，并关联注册用户，判断是否为次日登录（登录日期=注册日期+1 天）；
3.  步骤 3：按注册日期分组，统计注册用户数和次日留存用户数，留存率=次日留存用户数/注册用户数\*100%。

**SQL 示例**：

```sql
-- 统计次日、三日、七日留存率
-- 步骤1：获取目标时间段注册用户及注册日期
WITH register_user AS (
  SELECT
    user_id,
    DATE(register_time) AS register_date -- 提取注册日期（仅日期，无时间）
  FROM
    user_info
  WHERE
    DATE(register_time) BETWEEN '2025-10-01' AND '2025-10-07'
),
-- 步骤2：获取登录用户及登录日期，计算时间差
login_user_base AS (
  SELECT
    r.user_id,
    r.register_date,
    DATEDIFF(DATE(l.login_time), r.register_date) AS diff_days -- 计算登录与注册的日期差
  FROM
    register_user r
  LEFT JOIN
    login_info l
  ON
    r.user_id = l.user_id
  WHERE
    DATE(l.login_time) >= r.register_date -- 排除异常数据
)
-- 步骤3：统计各阶段留存率
SELECT
  register_date,
  COUNT(DISTINCT user_id) AS register_user_count, -- 注册用户数（去重）
  -- 次日留存率（Day 1）：间隔1天
  ROUND(
    COUNT(DISTINCT CASE WHEN diff_days = 1 THEN user_id END) / COUNT(DISTINCT user_id) * 100,
    2
  ) AS retention_1d_rate,
  -- 三日留存率（Day 3）：间隔3天
  ROUND(
    COUNT(DISTINCT CASE WHEN diff_days = 3 THEN user_id END) / COUNT(DISTINCT user_id) * 100,
    2
  ) AS retention_3d_rate,
  -- 七日留存率（Day 7）：3~7天内有登录（区间留存）
  ROUND(
    COUNT(DISTINCT CASE WHEN diff_days BETWEEN 3 AND 7 THEN user_id END) / COUNT(DISTINCT user_id) * 100,
    2
  ) AS retention_7d_rate
FROM
  login_user_base
GROUP BY
  register_date
ORDER BY
  register_date;
```

**产品关注要点**：次日留存是产品「冷启动效果」和「用户初始体验」的核心衡量指标，若次日留存偏低，产品需优化注册流程、初始功能引导等。

### 3. 去重统计（DISTINCT，高频）

产品经理常需要统计“唯一用户数”（如付费用户数、活跃用户数），核心用`DISTINCT`实现去重。

**题目**：现有用户行为表`behavior_info`（含`user_id`、`behavior_type`（1=浏览，2=收藏，3=下单）、`behavior_time`），请统计 2025 年 10 月有过下单行为的唯一用户数。

**SQL 示例**：

```sql
-- 统计10月下单唯一用户数
SELECT
  COUNT(DISTINCT user_id) AS order_user_count -- DISTINCT去重，统计唯一用户数
FROM
  behavior_info
WHERE
  behavior_type = 3 -- 筛选下单行为
  AND DATE(behavior_time) BETWEEN '2025-10-01' AND '2025-10-31';
```

**产品关注要点**：唯一下单用户数是产品「转化效果」的核心指标，用于评估产品交易功能的有效性。

## 三、 产品经理 SQL 面试易错点总结

1.  **WHERE vs HAVING**：WHERE 用于「分组前」筛选数据（针对原始行），HAVING 用于「分组后」筛选数据（针对分组结果），仅能使用分组字段或聚合函数；
2.  **COUNT(\*) vs COUNT(字段)**：COUNT(\*)统计所有非 NULL 行的数量，COUNT(字段)仅统计该字段非 NULL 的行数量，统计用户数优先用 COUNT(DISTINCT user_id)；
3.  **JOIN 类型选择**：需要保留左表所有数据（如所有用户）用 LEFT JOIN，仅需要两表匹配数据（如付费用户+订单）用 INNER JOIN，右连接（RIGHT JOIN）几乎不用；
4.  **窗口函数 vs GROUP BY**：GROUP BY 会合并分组数据，窗口函数保留原始行数据，排名、累计统计优先用窗口函数。

### 总结

产品经理 SQL 面试的核心是「业务导向」，记住三个关键：

1.  先拆解产品需求（如“留存率”先明确定义，再拆解步骤）；
2.  优先掌握高频语法（GROUP BY、JOIN、窗口函数、DISTINCT）；
3.  关注统计结果的业务意义（而非单纯写 SQL）。
